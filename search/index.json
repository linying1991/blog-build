[{"content":" 该文章源于 Stack Overflow：Fully backup a git repo? - Stack Overflow\n有时候需要对仓库进行备份，特别是 git 远端如果是部署在内网的话，进行全量备份非常有必要。\n操作一共有两步 1️⃣镜像克隆 git 远端仓库（全量） Git - git-clone Documentation\n包括远程跟踪分支、标签等\ngit clone --mirror 远端仓库地址.git 2️⃣更新镜像仓库 cd 进入仓库目录\ngit remote update 即使未来有新增分支，也一样能更新下来，并且被删除的分支不会从镜像中被删除\n扩展：打包为单个文件 依然需要 cd 进入仓库目录\ngit bundle create 仓库名.bundle --all ","date":"2022-08-14T00:00:00Z","permalink":"https://52haowu.cn/p/git-remote-backup/","title":"git 远端仓库全量备份"},{"content":"介绍 说到 Explorer 的命令行，我自己用得比较多的，就下边几种情况：\n打开（弹出）文件夹 定位文件或文件夹 例子 本文主要介绍第 2 种情况的命令行用法。\n命令开关比较简单，那就是 /select,文件路径。文件路径即便包含空格，也可以不用加 \u0026quot;。\nexplorer.exe /select,\u0026#34;C:\\Program Files\u0026#34;\rexplorer.exe /select,C:\\Program Files\rexplorer.exe /select,C:\\Windows\\notepad.exe 注意点 目录分割符必须用 \\，而不能用 /，否则无法正常定位到文件。\n更多知识点 还有其他我认为比较冷门的命令开关，有兴趣可进行了解。\n更多命令开关\u0026hellip;\n","date":"2022-03-26T00:00:00Z","permalink":"https://52haowu.cn/p/explorer_command_line/","title":"Explorer 命令行开关"},{"content":"GitHub Desktop 是一款操作简单，界面很好看的客户端。\n我为它添加了目录背景右键的功能，当鼠标在文件夹空白处右键，点击 GitHub Desktop，即可快速打开并定位到相关仓库（或添加仓库）。\n启用 将下方内容，你的用户名 改成你电脑的用户名，保存为 .reg 文件，双击导入注册表，立刻生效。\nWindows Registry Editor Version 5.00\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\GitHubDesktop]\r\u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Users\\\\%USERNAME%\\\\AppData\\\\Local\\\\GitHubDesktop\\\\GitHubDesktop.exe,0\u0026#34;\r@=\u0026#34;GitHub Desktop\u0026#34;\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\GitHubDesktop\\command]\r@=\u0026#34;C:\\\\Users\\\\你的用户名\\\\AppData\\\\Local\\\\GitHubDesktop\\\\bin\\\\github.bat \\\u0026#34;%V\\\u0026#34;\u0026#34; 停用 将下方内容，保存为 .reg 文件，双击导入注册表，立刻失效。\nWindows Registry Editor Version 5.00\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\GitHubDesktop] ","date":"2022-03-26T00:00:00Z","permalink":"https://52haowu.cn/p/github_desktop_contextmenu/","title":"给 GitHub Desktop 加上右键菜单"},{"content":" 官方介绍：\nWindows 终端程序是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。\n介绍 Windows Terminal 是 Windows 10 以后官方开源发布的一款终端，Windows 11 系统已经默认安装。\n特点 我主要是因为一、二点而很喜欢使用\n好看：界面很美观，用了这个再也不想用回系统自带的 cmd 了 右键菜单（安装后需重启资源管理器或重开机） 桌面右键 文件夹右键 文件夹背景右键 多标签页 丰富的快捷键 适用于命令行工具和命令提示符，PowerShell和 WSL 等 安装 应用商店安装 通过应用商店安装，可点击下方地址，或直接在 Microsoft Store 里边搜索 Terminal\n安装地址（应用商店）\n下载安装 可直接到官方开源仓库的 Release 里边下载，文件后缀为 .msixbundle，下载后双击安装即可\n下载地址（GitHub）\n","date":"2022-03-13T00:00:00Z","permalink":"https://52haowu.cn/p/windows_terminal/","title":"Windows Terminal，官方的新终端程序"},{"content":"在 vue.config.js 里把 publicPath 设置为 ./，打包后即可直接双击 html 查看，无需放到服务器里边。\nmodule.exports = { publicPath: \u0026#39;./\u0026#39; } ","date":"2022-03-13T00:00:00Z","permalink":"https://52haowu.cn/p/vue_cli_build_local/","title":"解决 Vue 生成的 dist 在本地打开失败"},{"content":" 可能仅适合英文和我一样比较不好的朋友\n有些资料，需要用到英文来进行搜索，而表达不准确的单词，会让你难以找到想要的结果。\n分享几个摸索出来的关键字。\nawesome 搜索编程语言、框架等周边的相关技术，可以搜到大量你想了解的。\n比如：awesome ruby、awesome go、awesome gin、awesome windows 等。\nalternatives 搜索替代方案，竞品。\n比如：google alternatives，可以搜到一堆搜索引擎；windows alternatives，可以搜到一堆操作系统。\nvs 搜索对比替代方案，竞品。\n比如：在搜索框输入 google vs ，等待搜索框的智能提示，也可以看到不少的替代方案。\n后面还有其他的再继续补充 😊\n","date":"2022-03-10T00:00:00Z","permalink":"https://52haowu.cn/p/search_keywords/","title":"几个英文搜索关键字"},{"content":"介绍 Chrome（包括 WebKit 版的 Edge）是支持通过命令行进行控制的，可以以此来改变浏览器的行为，或进行调试等等。\n比方说可以通过 --user-data-dir 命令行，通过自定义用户数据目录，创建多个独立空间的浏览器。\n例子 下方示例用于创建 4 个独立空间的浏览器，每个浏览器的插件、用户、历史数据、书签等都是独立存在的。\n如果想要经常这么使用，你可以通过创建快捷方式方便使用。\nchrome.exe \u0026#34;--user-data-dir=用户自定义数据路径1\u0026#34;\rchrome.exe \u0026#34;--user-data-dir=用户自定义数据路径2\u0026#34;\rchrome.exe \u0026#34;--user-data-dir=用户自定义数据路径3\u0026#34;\rchrome.exe \u0026#34;--user-data-dir=用户自定义数据路径4\u0026#34; 更多的开关 上边只是其中的一个例子，还有很多命令可使用，下方链接有汇总，有兴趣可查看。\nhttps://peter.sh/experiments/chromium-command-line-switches/\n","date":"2022-01-27T00:00:00Z","permalink":"https://52haowu.cn/p/chrome_switches/","title":"Chrome 命令行大全"},{"content":"介绍 Zip.js 是一个前端库，用于压缩和解压 zip 文件，运行于浏览器和 Deno。\n开源协议友好，适合使用。\n功能特性 支持 Zip64 格式 支持 WinZIP AES 和 PKWare ZipCrypto 加密技术 支持对一个或多个 Zip 文件的同时读和写 支持 Worker 无依赖性 兼容性 该库完全适用于最新版本的 Chrome、Firefox、Safari 和 Microsoft Edge。\n官网 访问\n","date":"2021-12-05T00:00:00Z","permalink":"https://52haowu.cn/p/zip_js/","title":"前端 Zip 压缩库"},{"content":"说明 xcopy 用于复制文件和目录树（即递归复制），配合自带的开关，功能强大。\n平时主要是配置自动化的时候用，也就是用得并不多，但是作用却很大。\n因此就很容易忘记命令和开关的作用以及目标结果，这里开一篇文章，把经常使用的列进来，作为一个记录，随时可搜索查看。\n开关说明 例子中，目标地址我都采用目录，其实文件也是可以的。\n开关 /I：如果目标不存在，且要复制多个文件，则假定目标必须是目录。 xcopy /I 源目录或文件 目标目录 开关 /E：复制目录和子目录，包括空目录。（即克隆整个目录，不包括隐藏和系统文件，如果需要，加上 /H） xcopy /I /E 源目录或文件 目标目录 开关 /Y：如果目标文件存在，自动覆盖。 xcopy /Y 源目录或文件 目标目录 开关 /Q：复制时不显示文件名。（复制完毕后仅显示复制了多少个文件） xcopy /Q 源目录或文件 目标目录 更多开关可通过下方命令进行查看 xcopy /? 使用例子 将源目录里边的文件（不含当前目录），复制到目标目录（自动创建目录，支持创建多级目录），并且\n包括子文件 自动覆盖 不显示复制的路径 xcopy /I /E /Y /Q 源目录 目标目录 ","date":"2021-11-26T00:00:00Z","permalink":"https://52haowu.cn/p/xcopy/","title":"xcopy 命令的常用开关"},{"content":"说明 RubyZip 用于 ruby 进行 zip 的压缩和解压\n仓库地址\n官方文档\n安装方法 gem install rubyzip 使用例子 # 配置例子 require \u0026#39;zip\u0026#39; Zip.setup do |c| # 当压缩包里边存在同名文件时，自动覆盖。但如果有同名文件夹，还是会抛异常 c.continue_on_exists_proc = true # 解压时自动覆盖文件 c.on_exists_proc = true # 强制编码为 UTF-8 c.force_entry_names_encoding = \u0026#39;UTF-8\u0026#39; # c.default_compression = Zlib::BEST_COMPRESSION end # 压缩例子 1 require \u0026#39;zip\u0026#39; input_file = \u0026#39;输入文件\u0026#39; output_zip = \u0026#39;输出 zip\u0026#39; Zip::File.open(output_zip, Zip::File::CREATE) do |zip_file| # 添加文件 # 文件名支持带有目录，会在压缩包里边自动创建目录 # 文件名需使用相对路径 zip_file.add(\u0026#39;文件\u0026#39;, input_file) zip_file.add(\u0026#39;文件夹/文件\u0026#39;, input_file) # 添加目录 zip_file.mkdir(\u0026#39;创建目录\u0026#39;) end # 压缩例子 2 # https://github.com/rubyzip/rubyzip/blob/9d891f7353e66052283562d3e252fe380bb4b199/samples/example_recursive.rb # 解压例子 # 解压时压缩包里边的文件夹会被自动创建（空目录也会被创建），但输出路径 output_dir 必须存在，否则抛异常 require \u0026#39;zip\u0026#39; input_zip = \u0026#39;zip 文件路径\u0026#39; output_dir = \u0026#39;输出路径\u0026#39; Zip::File.open(input_zip) do |zip_file| zip_file.each do |entry| entry.extract(File.join(output_dir, entry.name)) end end ","date":"2021-10-31T00:00:00Z","permalink":"https://52haowu.cn/p/rubyzip/","title":"RubyZip，压缩解压工具"},{"content":" 下方表格内容来自维基百科：HTTP头字段\nMDN 的也不错，也顺便贴上来：HTTP Headers\n请求字段 协议头字段名 说明 示例 状态 Accept 能够接受的回应内容类型（Content-Types）。参见内容协商。 Accept: text/plain 常设 Accept-Charset 能够接受的字符集 Accept-Charset: utf-8 常设 Accept-Encoding 能够接受的编码方式列表。参考HTTP压缩。 Accept-Encoding: gzip, deflate 常设 Accept-Language 能够接受的回应内容的自然语言列表。参考 内容协商 。 Accept-Language: en-US 常设 Accept-Datetime 能够接受的按照时间来表示的版本 Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT 临时 Authorization 用于超文本传输协议的认证的认证信息 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 常设 Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 Cache-Control: no-cache 常设 Connection 该浏览器想要优先使用的连接类型 Connection: keep-alive; Connection: Upgrade 常设 Cookie 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie Cookie: $Version=1; Skin=new; 常设: 标准 Content-Length 以 八位字节数组 （8位的字节）表示的请求体的长度 Content-Length: 348 常设 Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== 过时的 Content-Type 请求体的 多媒体类型 （用于POST和PUT请求中） Content-Type: application/x-www-form-urlencoded 常设 Date 发送该消息的日期和时间(按照 RFC 7231 中定义的\u0026quot;超文本传输协议日期\u0026quot;格式来发送) Date: Tue, 15 Nov 1994 08:12:31 GMT 常设 Expect 表明客户端要求服务器做出特定的行为 Expect: 100-continue 常设 From 发起此请求的用户的邮件地址 From: user@example.com 常设 Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。 Host: zh.wikipedia.org:80; Host: zh.wikipedia.org 常设 If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。 If-Match: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo; 常设 If-Modified-Since 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ） If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT 常设 If-None-Match 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 If-None-Match: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo; 常设 If-Range 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 If-Range: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo; 常设 If-Unmodified-Since 仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。 If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT 常设 Max-Forwards 限制该消息可被代理及网关转发的次数。 Max-Forwards: 10 常设 Origin 发起一个针对 跨来源资源共享 的请求（要求服务器在回应中加入一个‘访问控制-允许来源’（\u0026lsquo;Access-Control-Allow-Origin\u0026rsquo;）字段）。 Origin: http://www.example-social-network.com 常设: 标准 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 Pragma: no-cache 常设但不常用 Proxy-Authorization 用来向代理进行认证的认证信息。 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 常设 Range 仅请求某个实体的一部分。字节偏移以0开始。参见字节服务。 Range: bytes=500-999 常设 Referer 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。 Referer: http://zh.wikipedia.org/wiki/Main_Page 常设 TE 浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；另外还可用\u0026quot;trailers\u0026quot;（与\u0026quot;分块 \u0026ldquo;传输方式相关）这个值来表明浏览器希望在最后一个尺寸为0的块之后还接收到一些额外的字段。 TE: trailers, deflate 常设 User-Agent 浏览器的浏览器身份标识字符串 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 常设 Upgrade 要求服务器升级到另一个协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 常设 Via 向服务器告知，这个请求是由哪些代理发出的。 Via: 1.0 fred, 1.1 example.com (Apache/1.1) 常设 Warning 一个一般性的警告，告知，在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 常设 响应字段 字段名 说明 例子 状态 Access-Control-Allow-Origin 指定哪些网站可参与到跨来源资源共享过程中 Access-Control-Allow-Origin: * 临时 Accept-Patch 指定服务器支持的文件格式类型。 Accept-Patch: text/example;charset=utf-8 常设 Accept-Ranges 这个服务器支持哪些种类的部分内容范围 Accept-Ranges: bytes 常设 Age 这个对象在代理缓存中存在的时间，以秒为单位 Age: 12 常设 Allow 对于特定资源有效的动作。针对HTTP/405这一错误代码而使用 Allow: GET, HEAD 常设 Cache-Control 向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒 Cache-Control: max-age=3600 常设 Connection 针对该连接所预期的选项 Connection: close 常设 Content-Disposition 一个可以让客户端下载文件并建议文件名的头部。文件名需要用双引号包裹。 Content-Disposition: attachment; filename=\u0026ldquo;fname.ext\u0026rdquo; 常设 Content-Encoding 在数据上使用的编码类型。参考 超文本传输协议压缩 。 Content-Encoding: gzip 常设 Content-Language 内容所使用的语言 Content-Language: da 常设 Content-Length 回应消息体的长度，以 字节 （8位为一字节）为单位 Content-Length: 348 常设 Content-Location 所返回的数据的一个候选位置 Content-Location: /index.htm 常设 Content-MD5 回应内容的二进制 MD5 散列，以 Base64 方式编码 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== 过时的 Content-Range 这条部分消息是属于某条完整消息的哪个部分 Content-Range: bytes 21010-47021/47022 常设 Content-Type 当前内容的MIME类型 Content-Type: text/html; charset=utf-8 常设 Date 此条消息被发送时的日期和时间(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Date: Tue, 15 Nov 1994 08:12:31 GMT 常设 ETag 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列 ETag: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo; 常设 Expires 指定一个日期/时间，超过该时间则认为此回应已经过期 Expires: Thu, 01 Dec 1994 16:00:00 GMT 常设: 标准 Last-Modified 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT 常设 Link 用来表达与另一个资源之间的类型关系，此处所说的类型关系是在 RFC 5988 中定义的 Link: ; rel=\u0026ldquo;alternate\u0026rdquo; 常设 Location 用来 进行重定向，或者在创建了某个新资源时使用。 Location: http://www.w3.org/pub/WWW/People.html 常设 P3P 用于支持设置P3P策略，标准格式为“P3P:CP=\u0026ldquo;your_compact_policy\u0026rdquo;”。然而P3P规范并不成功，大部分现代浏览器没有完整实现该功能，而大量网站也将该值设为假值，从而足以用来欺骗浏览器的P3P插件功能并授权给第三方Cookies。 P3P: CP=\u0026ldquo;This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en\u0026answer=151657 for more info.\u0026rdquo; 常设 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 Pragma: no-cache 常设 Proxy-Authenticate 要求在访问代理时提供身份认证信息。 Proxy-Authenticate: Basic 常设 Public-Key-Pins 用于缓解中间人攻击，声明网站认证使用的传输层安全协议证书的散列值 Public-Key-Pins: max-age=2592000; pin-sha256=\u0026ldquo;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\u0026rdquo;; 常设 Refresh 用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至“http://www.w3.org/pub/WWW/People.html”。 Refresh: 5; url=http://www.w3.org/pub/WWW/People.html 专利并非标准 Retry-After 如果某个实体临时不可用，则，此协议头用来告知客户端日后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 Example 1: Retry-After: 120; Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT 常设 Server 服务器的名字 Server: Apache/2.4.1 (Unix) 常设 Set-Cookie HTTP cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 常设: 标准 Status 通用网关接口 协议头字段，用来说明当前这个超文本传输协议回应的 状态 。普通的超文本传输协议回应，会使用单独的“状态行”（\u0026ldquo;Status-Line\u0026rdquo;）作为替代，这一点是在 RFC 7230 中定义的。 Status: 200 OK Not listed as a registered field name（页面存档备份，存于互联网档案馆） Strict-Transport-Security HTTP 严格传输安全这一头部告知客户端缓存这一强制 HTTPS 策略的时间，以及这一策略是否适用于其子域名。 Strict-Transport-Security: max-age=16070400; includeSubDomains 常设: 标准 Trailer 这个头部数值指示了在这一系列头部信息由由分块传输编码编码。 Trailer: Max-Forwards 常设 Transfer-Encoding 用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity。 Transfer-Encoding: chunked 常设 Upgrade 要求客户端升级到另一个协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 常设 Vary 告知下游的代理服务器，应当如何对未来的请求协议头进行匹配，以决定是否可使用已缓存的回应内容而不是重新从原始服务器请求新的内容。 Vary: * 常设 Via 告知代理服务器的客户端，当前回应是通过什么途径发送的。 Via: 1.0 fred, 1.1 example.com (Apache/1.1) 常设 Warning 一般性的警告，告知在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 常设 WWW-Authenticate 表明在请求获取这个实体时应当使用的认证模式。 WWW-Authenticate: Basic 常设 X-Frame-Options 点击劫持保护：deny：该页面不允许在 frame 中展示，即使是同域名内。sameorigin：该页面允许同域名内在 frame 中展示。allow-from uri：该页面允许在指定uri的 frame 中展示。allowall：允许任意位置的frame显示，非标准值。 X-Frame-Options: deny 过时的 ","date":"2021-09-05T00:00:00Z","permalink":"https://52haowu.cn/p/http-headers/","title":"HTTP 头字段大全"},{"content":"在 vue.config.js 里把 productionSourceMap 设置为 false，项目生产打包就不会出现 .map 文件了。\nmodule.exports = { productionSourceMap: false } ","date":"2021-08-04T00:00:00Z","permalink":"https://52haowu.cn/p/vue-build-without-map/","title":"Vue 项目打包时去掉 .map 文件"},{"content":" 引用自 MDN：HTTP 响应代码\nHTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。状态代码由 section 10 of RFC 2616定义\n信息响应 100 Continue\n这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。\n101 Switching Protocol\n该代码是响应客户端的 Upgrade (en-US) 标头发送的，并且指示服务器也正在切换的协议。\n102 Processing (WebDAV)\n此代码表示服务器已收到并正在处理该请求，但没有响应可用。\n103 Early Hints\n此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。\n成功响应 200 OK\n请求成功。成功的含义取决于HTTP方法：GET：资源已被提取并在消息正文中传输。HEAD：实体标头位于消息正文中。POST：描述动作结果的资源在消息体中传输。TRACE：消息正文包含服务器收到的请求消息\n201 Created\n该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。\n202 Accepted\n请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。\n203 Non-Authoritative Information\n服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。\n204 No Content\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n205 Reset Content\n服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\n206 Partial Content\n服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。\n207 Multi-Status (WebDAV)\n由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n208 Already Reported (WebDAV)\n在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。\n226 IM Used (HTTP Delta encoding)\n服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。\n重定向 300 Multiple Choice\n被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\n301 Moved Permanently\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n302 Found\n请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n303 See Other\n对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。\n304 Not Modified\n如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。\n305 Use Proxy\n被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。\n306 unused\n在最新版的规范中，306 状态码已经不再被使用。\n307 Temporary Redirect\n请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n308 Permanent Redirect\n这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。\n客户端响应 400 Bad Request\n1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。\n2、请求参数有误。\n401 Unauthorized\n当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。\n402 Payment Required\n此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。\n403 Forbidden\n服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。\n404 Not Found\n请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 Method Not Allowed\n请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 Not Acceptable\n请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。\n407 Proxy Authentication Required\n与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。\n408 Request Timeout\n请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\n409 Conflict\n由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。\n410 Gone\n被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。\n411 Length Required\n服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\n412 Precondition Failed\n服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 Payload Too Large\n服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 URI Too Long\n请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。\n415 Unsupported Media Type\n对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\n416 Range Not Satisfiable\n如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。\n417 Expectation Failed\n此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。\n418 I'm a teapot\n服务器拒绝尝试用 “茶壶冲泡咖啡”。\n421 Misdirected Request\n该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。\n422 Unprocessable Entity (WebDAV)\n请求格式良好，但由于语义错误而无法遵循。\n423 Locked (WebDAV)\n正在访问的资源被锁定。\n424 Failed Dependency (WebDAV)\n由于先前的请求失败，所以此次请求失败。\n425 Too Early\n服务器不愿意冒着风险去处理可能重播的请求。\n426 Upgrade Required\n服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade (en-US) 头以指示所需的协议。\n428 Precondition Required\n原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。\n429 Too Many Requests\n用户在给定的时间内发送了太多请求（“限制请求速率”）。\n431 Request Header Fields Too Large\n服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。\n451 Unavailable For Legal Reasons\n用户请求非法资源，例如：由政府审查的网页。\n服务端响应 500 Internal Server Error\n服务器遇到了不知道如何处理的情况。\n501 Not Implemented\n此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。\n502 Bad Gateway\n此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。\n503 Service Unavailable\n服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。\n504 Gateway Timeout\n当服务器作为网关，不能及时得到响应时返回此错误代码。\n505 HTTP Version Not Supported\n服务器不支持请求中所使用的HTTP协议版本。\n506 Variant Also Negotiates\n服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。\n507 Insufficient Storage\n服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。\n508 Loop Detected (WebDAV)\n服务器在处理请求时检测到无限循环。\n510 Not Extended\n客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。\n511 Network Authentication Required\n511 状态码指示客户端需要进行身份验证才能获得网络访问权限。\n","date":"2021-06-29T00:00:00Z","permalink":"https://52haowu.cn/p/http-status-code/","title":"HTTP 响应代码大全"},{"content":"windows 系统下，Ruby 的某些 gem 包需要 DevKit 才能正常安装，2.4 以后的版本可以一键安装 DevKit，之前的版本只能手动安装。\n2.4 以后的可以到官网下载：https://rubyinstaller.org/downloads/ 下载 WITH DEVKIT 的版本即可。\n我遇到安装后找不到 make 的情况，上网搜索后尝试的解决方案。\n参考地址：https://www.cnblogs.com/zxktxj/archive/2013/01/04/2843556.html\n根据博文尝试后，在我这主要就是检查 devkit.rb 和 operating_system.rb 这两个文件里边的文件夹路径。\nC:\\Ruby22-x64\\lib\\ruby\\site_ruby\\devkit.rb\nC:\\Ruby22-x64\\lib\\ruby\\2.2.0\\rubygems\\defaults\\operating_system.rb\n比如我的电脑上的 devkit.rb，有很明显的文件夹路径对不上：\u0026lsquo;D:\\Program Files\\DevKit\\mingw\\bin\u0026rsquo;，我的 DevKit 安装的位置压根就不是在这里。\n可能是因为我系统里边的环境变量混乱导致的，把文件夹路径改对保存即可\n# enable RubyInstaller DevKit usage as a vendorable helper library unless ENV[\u0026#39;PATH\u0026#39;].include?(\u0026#39;D:\\\\Program Files\\\\DevKit\\\\mingw\\\\bin\u0026#39;) then phrase = \u0026#39;Temporarily enhancing PATH to include DevKit...\u0026#39; if defined?(Gem) Gem.ui.say(phrase) if Gem.configuration.verbose else puts phrase end puts \u0026#34;Prepending ENV[\u0026#39;PATH\u0026#39;] to include DevKit...\u0026#34; if $DEBUG ENV[\u0026#39;PATH\u0026#39;] = \u0026#39;D:\\\\Program Files\\\\DevKit\\\\bin;D:\\\\Program Files\\\\DevKit\\\\mingw\\\\bin;\u0026#39; + ENV[\u0026#39;PATH\u0026#39;] end ENV[\u0026#39;RI_DEVKIT\u0026#39;] = \u0026#39;D:\\\\Program Files\\\\DevKit\u0026#39; ENV[\u0026#39;CC\u0026#39;] = \u0026#39;gcc\u0026#39; ENV[\u0026#39;CXX\u0026#39;] = \u0026#39;g++\u0026#39; ENV[\u0026#39;CPP\u0026#39;] = \u0026#39;cpp\u0026#39; 就这样解决了，一般情况下，如果 DevKit 正确安装但仍然不能用，那么上面这种方式就可以试试。\n","date":"2019-12-04T00:00:00Z","permalink":"https://52haowu.cn/p/ruby-devkit-install-failed/","title":"ruby2.2 DevKit 安装后无法使用解决方案"},{"content":"PC 微信本身是不允许多开的，但是却有多开的方法。\n方法是：第一步，退出当前的微信；第二步，快速连续多次启动微信。\n这个人工操作还是有点难度，但是用脚本就简单多了。脚本代码如下：\n@echo off echo 请先退出微信 PC 客户端，再执行该程序！ pause start \u0026#34;\u0026#34; \u0026#34;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe\u0026#34; start \u0026#34;\u0026#34; \u0026#34;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe\u0026#34; 保存脚本步骤：新建一个 .txt，把以上代码保存到 .txt 里边，然后把 .txt 修改为 .bat，双击就可以启动了。\n代码执行流程：1，杀掉微信的进程；2，连续启动两次微信。\n如何三开乃至更多开？把 start 这行代码多复制几行。\n注意：因为会杀进程，所以在使用脚本之前，你要先保证微信里边没有正在编辑的内容。\n","date":"2019-11-29T00:00:00Z","permalink":"https://52haowu.cn/p/pc-wechat-multi-run/","title":"PC 微信多开工具"},{"content":"JetBrains 本身不带迷你地图功能，但可以通过插件的形式来实现。\n直接在 Settings 里边搜索 CodeGlance，安装后重启 IDE 就有了。\n","date":"2019-11-28T00:00:00Z","permalink":"https://52haowu.cn/p/jetbrains-minimap-plugin/","title":"JetBrains 迷你地图插件 CodeGlance"},{"content":"RubyGem 下载 gem 包失败，有一定原因是 https 导致的。\n搜索了很久，找到一个解决的方法。\n1、下载 cacert.pem，也就是 curl 的证书。 http://curl.haxx.se/ca/cacert.pem\nOpenSSL 使用 PEM 文件格式存储证书和密钥。\n2、放到指定版本 ruby 目录里边，我这里使用的是 2.2 的版本 C:\\Ruby22-x64\\lib\\ruby\\2.2.0\\rubygems\\ssl_certs\\\n3、现在可以再试试\n","date":"2019-11-28T00:00:00Z","permalink":"https://52haowu.cn/p/ruby-gem-download-failed/","title":"RubyGem 下载失败的解决方法"}]